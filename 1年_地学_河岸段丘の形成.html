<!doctype html>
<html lang="ja">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>河岸段丘シミュレーター v1（断面・超シンプル｜T5で終了）</title>
<style>
  :root{ --bg:#fafafa; --panel:#ffffff; --ink:#111; --muted:#475569; --line:#e5e7eb; --accent:#2563eb; }
  html,body{height:100%}
  body{margin:0; font-family:system-ui, -apple-system, Segoe UI, Roboto, "Noto Sans JP", Helvetica, Arial; color:var(--ink); background:linear-gradient(180deg,#ffffff,#f7fbff 80%);} 
  header{padding:12px 16px; display:flex; gap:12px; align-items:center; border-bottom:1px solid var(--line); position:sticky; top:0; background:rgba(255,255,255,0.85); backdrop-filter:saturate(180%) blur(8px);} 
  header h1{font-size:18px; margin:0; font-weight:800; letter-spacing:0.02em}
  .container{display:grid; grid-template-columns: 340px 1fr; gap:16px; padding:16px;}
  .panel{background:var(--panel); border:1px solid var(--line); border-radius:14px; box-shadow:0 4px 18px rgba(0,0,0,.06);} 
  .controls{padding:14px; display:flex; flex-direction:column; gap:14px;}
  .group{border:1px dashed var(--line); border-radius:12px; padding:12px;}
  .group h3{margin:0 0 8px 0; font-size:14px;}
  label{font-size:13px; display:flex; align-items:center; justify-content:space-between; gap:10px; margin:6px 0;}
  input[type="range"]{width:160px;}
  .row{display:flex; flex-wrap:wrap; gap:8px; align-items:center;}
  .btn{appearance:none; border:1px solid var(--line); background:#fff; padding:8px 10px; border-radius:10px; cursor:pointer; font-weight:700;}
  .btn:hover{border-color:#cbd5e1;}
  .btn.primary{background:var(--accent); color:#fff; border-color:transparent;}
  .legend{font-size:12px; color:var(--muted);}
  canvas{width:100%; height:560px; display:block; border-radius:14px;}
  .notice{font-size:12px; color:#334155; background:#eff6ff; border:1px solid #dbeafe; padding:8px 10px; border-radius:10px;}
</style>
</head>
<body>
  <header>
    <h1>河岸段丘シミュレーター v1（断面・超シンプル｜T5で終了）</h1>
    <div class="row" style="margin-left:auto;">
      <button id="btnPlay" class="btn primary">▶ 開始</button>
      <button id="btnStep" class="btn">⏭ 次フェーズ</button>
      <button id="btnReset" class="btn">⟲ リセット</button>
      <button id="btnSave" class="btn">🖼 PNG保存</button>
    </div>
  </header>

  <div class="container">
    <aside class="panel">
      <div class="controls">
        <div class="group">
          <h3>基本設定（最小）</h3>
          <label>時間倍率 <input id="timeScale" type="range" min="0.1" max="5" value="1" step="0.1"><span><span id="timeScaleVal">1.0</span>×</span></label>
          <label>フェーズ長（kyr）<input id="phaseDur" type="range" min="0.5" max="10" value="2" step="0.5"><span id="phaseDurVal">2.0</span></label>
          <label>下刻量 / 1サイクル（m）<input id="Hinc" type="range" min="2" max="40" value="12" step="1"><span id="HincVal">12</span></label>
          <label>隆起量 / 1サイクル（m）<input id="Hup" type="range" min="0" max="20" value="5" step="1"><span id="HupVal">5</span></label>
          <label>拡幅速度（m/kyr）<input id="Fgrow" type="range" min="5" max="80" value="30" step="1"><span id="FgrowVal">30</span></label>
          <label>氾濫原 最大半幅（m）<input id="Fmax" type="range" min="60" max="220" value="160" step="5"><span id="FmaxVal">160</span></label>
        </div>
        <div class="notice">下刻 → 隆起 → 拡幅 を繰り返し、<b>T5</b>が生成されたところで自動停止します（段は必ず左上・右上に向かって外上がり）。</div>
      </div>
    </aside>

    <main class="panel" style="padding:10px;">
      <canvas id="cv" width="1200" height="560" aria-label="河岸段丘シミュレーション"></canvas>
      <div class="legend" id="legend" style="padding:8px 12px;">
        時間: <span id="timeLabel">0.0</span> kyr ／ フェーズ: <span id="phaseLabel">—</span> ／ 段丘数: <span id="nTerraces">0</span>
      </div>
    </main>
  </div>

  <footer style="padding:8px 16px; font-size:12px; color:#64748b;">
    © 2025 河岸段丘シミュレーター v1（断面・超シンプル） | 授業用（オフライン可）
  </footer>

<script>
(()=>{
  const $ = (q)=>document.querySelector(q);
  const cv = $('#cv');
  const ctx = cv.getContext('2d');
  const W = cv.width, H = cv.height;
  const PX_PER_M = 2.2;
  const X0 = W/2;
  const VALLEY_HALF_WIDTH_M = 420;
  const HX = W/(VALLEY_HALF_WIDTH_M*2);

  const HILL_RISE = 140;
  const BANKFULL = 2;
  const WCHAN = 20;
  const BENCH_W = 80;
  const BENCH_GAP = 10; // 新旧段丘の最小横方向オフセット
  const MAX_TERRACES = 5; // 打ち切り（T5）

  const linkRange = (id, fmt=(v)=>v)=>{ const el=$(id), out=$(id+'Val'); const f=()=>{ if(out) out.textContent = fmt(parseFloat(el.value)); }; el.addEventListener('input', f); f(); return ()=>parseFloat(el.value); };
  const getTimeScale = linkRange('#timeScale', v=>v.toFixed(1));
  const getPhaseDur  = linkRange('#phaseDur', v=>v.toFixed(1));
  const getHinc      = linkRange('#Hinc');
  const getHup       = linkRange('#Hup');
  const getFgrow     = linkRange('#Fgrow');
  const getFmax      = linkRange('#Fmax');

  let t=0, running=false;
  let phaseIdx = 0; // 0=下刻, 1=隆起, 2=拡幅
  let phaseElapsed = 0;
  let zc = 30;
  let terraces=[]; // {h, F}
  let completed=false;

  $('#btnPlay').addEventListener('click', ()=>{ running=!running; $('#btnPlay').textContent= running?'⏸ 停止':'▶ 開始'; loop(); });
  $('#btnStep').addEventListener('click', ()=>{ if(!running){ nextPhase(true); draw(); }});
  $('#btnReset').addEventListener('click', ()=> reset());
  $('#btnSave').addEventListener('click', ()=>{ const a=document.createElement('a'); a.download=`river_terrace.png`; a.href=cv.toDataURL('image/png'); a.click(); });

  function reset(){ t=0; phaseIdx=0; phaseElapsed=0; zc=30; terraces.length=0; completed=false; running=false; $('#btnPlay').textContent='▶ 開始'; draw(); updateLegend(); }
  function updateLegend(){ $('#timeLabel').textContent=t.toFixed(1); $('#phaseLabel').textContent = completed ? '完了 (T5)' : ['下刻','隆起','拡幅'][phaseIdx]; $('#nTerraces').textContent=terraces.length; }

  function ypx(h){ const originY = H*0.86; return originY - h*PX_PER_M; }
  function xpx(xm){ return X0 + xm*HX; }

  function enforceStaircase(){
    // 古い段ほど外側へ：F[i] >= F[i+1] + BENCH_W + BENCH_GAP
    const MAX = VALLEY_HALF_WIDTH_M - 20;
    for(let i=terraces.length-2; i>=0; i--){
      const need = terraces[i+1].F + BENCH_W + BENCH_GAP;
      terraces[i].F = Math.max(terraces[i].F, need);
      terraces[i].F = Math.min(terraces[i].F, MAX - BENCH_W);
    }
  }

  function step(dt){
    const phaseDur = getPhaseDur();
    const Hinc = getHinc();
    const Hup = getHup();
    const Fgrow = getFgrow();
    const Fmax = getFmax();

    phaseElapsed += dt; t += dt;

    if(completed){ return; }

    if(phaseIdx===0){
      if(phaseElapsed===dt){
        if(terraces.length >= MAX_TERRACES){
          completed = true; running=false; $('#btnPlay').textContent='▶ 開始'; updateLegend(); return;
        }
        zc -= Hinc;
        terraces.push({h: zc + BANKFULL, F: WCHAN/2});
        if(terraces.length >= MAX_TERRACES){
          completed = true; running=false; $('#btnPlay').textContent='▶ 開始'; updateLegend(); return;
        }
      }
    } else if(phaseIdx===1){
      const rate = Hup/phaseDur;
      const du = rate*dt; zc += du; terraces.forEach(b=> b.h += du);
    } else if(phaseIdx===2){
      const cur = terraces[terraces.length-1]; if(cur){ cur.F = Math.min(Fmax, cur.F + Fgrow*dt); }
    }

    if(terraces.length>1) enforceStaircase();
    if(terraces.length >= MAX_TERRACES){ completed = true; running=false; $('#btnPlay').textContent='▶ 開始'; }
    if(phaseElapsed >= phaseDur && !completed){ nextPhase(false); }
    updateLegend();
  }

  function nextPhase(manual){ if(completed) return; phaseElapsed = 0; phaseIdx = (phaseIdx + 1) % 3; if(manual){ t += getPhaseDur(); } }

  function drawFrame(){
    const g = ctx.createLinearGradient(0,0,0,H); g.addColorStop(0,'#f0f9ff'); g.addColorStop(1,'#ffffff'); ctx.fillStyle=g; ctx.fillRect(0,0,W,H);
    ctx.strokeStyle='rgba(0,0,0,0.08)'; ctx.lineWidth=1; for(let h=-200; h<=400; h+=20){ const y=ypx(h); if(y>0&&y<H){ ctx.beginPath(); ctx.moveTo(0,y); ctx.lineTo(W,y); ctx.stroke(); } }
  }

  function draw(){
    ctx.clearRect(0,0,W,H); drawFrame();

    const list = terraces.slice().sort((a,b)=>b.h - a.h);
    const leftTop  = {x: xpx(-VALLEY_HALF_WIDTH_M), y: ypx(zc + HILL_RISE)};
    const rightTop = {x: xpx(+VALLEY_HALF_WIDTH_M), y: ypx(zc + HILL_RISE)};

    const cur = terraces[terraces.length-1];
    const Fcur = cur ? Math.max(cur.F, WCHAN/2) : WCHAN/2;
    const leftToe  = {x: xpx(-Fcur), y: ypx(zc + BANKFULL)};
    const rightToe = {x: xpx(+Fcur), y: ypx(zc + BANKFULL)};

    ctx.beginPath(); ctx.moveTo(leftTop.x, leftTop.y);
    for(let i=0;i<list.length;i++){
      const b = list[i]; const y = ypx(b.h);
      const xOuter = xpx(-(b.F + BENCH_W)); const xInner = xpx(-(b.F));
      ctx.lineTo(xOuter, y);
      ctx.lineTo(xInner, y);
      const next = list[i+1]; if(next){ ctx.lineTo(xInner, ypx(next.h)); }
    }
    ctx.lineTo(leftToe.x, leftToe.y);
    ctx.lineTo(rightToe.x, rightToe.y);
    for(let i=list.length-1;i>=0;i--){
      const b = list[i]; const y = ypx(b.h);
      const xInner = xpx(+(b.F)); const xOuter = xpx(+(b.F + BENCH_W));
      ctx.lineTo(xInner, y);
      ctx.lineTo(xOuter, y);
    }
    ctx.lineTo(rightTop.x, rightTop.y); ctx.closePath();
    ctx.fillStyle = '#efe5d9'; ctx.fill();
    ctx.strokeStyle = 'rgba(71,85,105,0.9)'; ctx.lineWidth = 1.5; ctx.stroke();

    ctx.fillStyle = 'rgba(190,242,100,0.35)';
    ctx.fillRect(xpx(-Fcur), ypx(zc+BANKFULL)-6, xpx(+Fcur)-xpx(-Fcur), 12);

    ctx.fillStyle = '#60a5fa';
    ctx.fillRect(xpx(-WCHAN/2), ypx(zc), xpx(+WCHAN/2)-xpx(-WCHAN/2), 10);

    for(let i=0;i<list.length;i++){
      const b = list[i]; const y = ypx(b.h);
      const xR2 = xpx(+(b.F + BENCH_W));
      ctx.fillStyle='#0f172a'; ctx.font='12px ui-sans-serif'; ctx.fillText(`T${i+1}`, xR2+6, y+4);
    }
  }

  function loop(){ if(!running) return; const dt = 0.3 * getTimeScale(); step(dt); draw(); requestAnimationFrame(loop); }

  reset();
})();
</script>
</body>
</html>